We can prevent(stop) a Thread execution by using the following methods.
1. yield()
2. join()
3. sleep()

yield(): 
1. Yield() method causes to pause the current execution thread and giving the chance of remaining waiting threads of same priority.
2. If all waiting threads are low priority or if there is no waiting threads then the same thread will be continued.
3. If several waiting threads with same priority available then we can't expect exact which thread will get chance for execution.
4. The thread which is yielded when it get chance once again for execution it depends on mercy of the thread sheduler.

public class ThreadYieldDemo {

	public static void main(String[] args) {

		
		Mythread thread = new Mythread();
		thread.start();
		for(int i=0;i<5;i++) {
			System.out.println("Main thread");
		}
	}

}

class Mythread extends Thread{
	
	@Override
	public void run() {
		for(int i=0;i<5;i++) {
			Thread.yield();
			System.out.println("Child Thread");
		}
	}
}


join():-
1. If a thread wants to wait() until completing some other thread then we should go for join() method.
example:
If a Thread  t1 executes t2.join() then t1 should go for waiting state until completing t2.

public class Threadjoindemo {

	public static void main(String[] args) throws InterruptedException {

		Mythred1 t1 = new Mythred1();
		t1.start();
		t1.join();
		for(int i=0;i<5;i++) {
			System.out.println("Rama thread.");
		}
	}

}
class Mythred1 extends Thread{
	
	@Override
	public void run() {

		for(int i=0;i<5;i++) {
			System.out.println("seetha thread");
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
}

If a thread calls notify() on any object , it releases the lock of that object but may not immediately.
Except wait,notify,notifyall there is no other method where thread releases the lock.
Which of the following is valid
1. If a thread calls wait() immediately it will entered into waiting state with out releasing any lock invalid
2. If a thread calls wait() it releases the lock of that object,but may not immediately invalid
3. If a thread calls wait() on any object it releases all locks acquired by that thread and immediately entered into waiting state invalid.
4. If a thread calls wait() on any object it immediately releases the lock of that particular object and entered into waiting state. valid
5. If a thread calls notify() on any object it immediately relases the lock of that particular object invalid.
6. If a thread calls notify() on any object it releases the lock of that object , but may not immediately  valid.







