We can prevent(stop) a Thread execution by using the following methods.
1. yield()
2. join()
3. sleep()

yield(): 
1. Yield() method causes to pause the current execution thread and giving the chance of remaining waiting threads of same priority.
2. If all waiting threads are low priority or if there is no waiting threads then the same thread will be continued.
3. If several waiting threads with same priority available then we can't expect exact which thread will get chance for execution.
4. The thread which is yielded when it get chance once again for execution it depends on mercy of the thread sheduler.

public class ThreadYieldDemo {

	public static void main(String[] args) {

		
		Mythread thread = new Mythread();
		thread.start();
		for(int i=0;i<5;i++) {
			System.out.println("Main thread");
		}
	}

}

class Mythread extends Thread{
	
	@Override
	public void run() {
		for(int i=0;i<5;i++) {
			Thread.yield();
			System.out.println("Child Thread");
		}
	}
}


join():-
1. If a thread wants to wait() until completing some other thread then we should go for join() method.
example:
If a Thread  t1 executes t2.join() then t1 should go for waiting state until completing t2.

public class Threadjoindemo {

	public static void main(String[] args) throws InterruptedException {

		Mythred1 t1 = new Mythred1();
		t1.start();
		t1.join();
		for(int i=0;i<5;i++) {
			System.out.println("Rama thread.");
		}
	}

}
class Mythred1 extends Thread{
	
	@Override
	public void run() {

		for(int i=0;i<5;i++) {
			System.out.println("seetha thread");
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
}

If a thread calls notify() on any object , it releases the lock of that object but may not immediately.
Except wait,notify,notifyall there is no other method where thread releases the lock.
Which of the following is valid
1. If a thread calls wait() immediately it will entered into waiting state with out releasing any lock invalid
2. If a thread calls wait() it releases the lock of that object,but may not immediately invalid
3. If a thread calls wait() on any object it releases all locks acquired by that thread and immediately entered into waiting state invalid.
4. If a thread calls wait() on any object it immediately releases the lock of that particular object and entered into waiting state. valid
5. If a thread calls notify() on any object it immediately relases the lock of that particular object invalid.
6. If a thread calls notify() on any object it releases the lock of that object , but may not immediately  valid.


Inter thread communication:--
------------------
Synchronized threads to communicate to each other


public class BankAccount {
	
	private int amount=10000;
	
	synchronized void withdraw(int amount){
		
		System.out.println("Going to withdraw.....");
		if(this.amount < amount){
			System.out.println("Less balance,waiting for deposit....");
			try{
				wait();
			}catch(Exception e)
			{
				e.printStackTrace();
			}
		}
		this.amount -= amount;
		System.out.println("Withdraw completed...");
		
	}

	synchronized void deposit(int amount){
		System.out.println("Going to deposit");
		this.amount +=amount;
		System.out.println("deposit completed..");
		notify();
	}
}
public class Sample {

	
	public static void main(String[] args) {

		final BankAccount bankAccount =  new BankAccount();
		new Thread("Thread 1"){
			public void run() {
				bankAccount.withdraw(50000);
			};
		}.start();
		
		new Thread("Thread 2"){
			public void run() {
				bankAccount.deposit(80000);
			};
		}.start();
	}

}

Locks:--
---------------
ReentrantLock:-- It is the implementation class of Lock interface and it is the direct child class of object.
                 Reentrant means a thread can acquire same lock multiple times without any issue.
		 internally reentrant lock increments threads personal count whenever we called lock method and
		 decrements count value whenever thread calls unlock() and lock will be released, whenever count reaches 
		 zero.
Constructors:--
---------------- ReentrantLock l = new ReentrantLock();
                creates an instance of reentrant lock .
	    2.  ReentrantLock l = new ReentrantLock(boolean fairness); creates reentrant lock with given fairness policy 
	        it the fairness is true then longest waiting thread can acquire the lock if it is available i.e it follows
		First come first serve policy, if fairness is false then which waiting thread will get the chance we cant 
		expect.
		The default value for fairness is False.
		which of the folloing declarations are equal.
		ReentrantLock l = new ReentranctLock();
		ReentrantLock l2 = new ReentranctLock(true);
		ReentrantLock l3 = new ReentranctLock(false); 
		All the above if 1 and l3 rd are equal
		
		Important methods of ReentrantLock:--
		void lock()
		boolean trylock()
		boolean trylock(Long l,TimeUnit t)
		void lockinterruptibly()
		void unlock()
		

public class ReentrantLockDemo {

	public static void main(String[] args) {
		Display d = new Display();
		Mythread t1 = new Mythread(d, "muthu");
		Mythread t2 = new Mythread(d, "raju");
		Mythread t3 = new Mythread(d, "dakshith");

		t1.start();
		t2.start();
		t3.start();
	}
}

class Mythread extends Thread{
	
	Display d;
	String name;
	
	public Mythread(Display d,String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}



class Display {

	ReentrantLock lock = new ReentrantLock();
	
	public  void wish(String name) {
		
		lock.lock();
		
		for(int i=0;i<5;i++) {
			
			System.out.print("Good Morning :");
            
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			System.out.println(name);
		}
		lock.unlock();
	}
}	
	   
-----------------------------------

public class SynchronizedDemo {

	public static void main(String[] args) {
		Display d = new Display();
		Mythread t1 = new Mythread(d, "muthu");
		Mythread t2 = new Mythread(d, "raju");
		Mythread t3 = new Mythread(d, "dakshith");

		t1.start();
		t2.start();
		t3.start();
	}
}

class Mythread extends Thread{
	
	Display d;
	String name;
	
	public Mythread(Display d,String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}



class Display {

	public  void wish(String name) {
		
		for(int i=0;i<5;i++) {
			
			System.out.print("Good Morning :");
            
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			System.out.println(name);
		}
		
	}
}



